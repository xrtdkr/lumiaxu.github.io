<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.1.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.2">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.2" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.1.2',
    sidebar: {"position":"left","width":280,"display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Coroutine in Python引言: 本文出自David Beazley 的关于协程的PPT，现在笔者将他翻译过来。并整理成文。感谢在协程方面的专家David Beazley， 能给我们这么深入的协程上面的讲座。也希望本文能给更多pythoner普及yield的更多用法，使python的这个特性能够更加多的活跃在大家的代码中。 源PPT和源码可以从这里下载：http://www.dabea">
<meta name="keywords" content="协程,Python">
<meta property="og:type" content="article">
<meta property="og:title" content="Python中的携程">
<meta property="og:url" content="http://lumiaxu.com/2017/12/05/Python中的携程/index.html">
<meta property="og:site_name" content="LumiaXu&#39;s Blog">
<meta property="og:description" content="Coroutine in Python引言: 本文出自David Beazley 的关于协程的PPT，现在笔者将他翻译过来。并整理成文。感谢在协程方面的专家David Beazley， 能给我们这么深入的协程上面的讲座。也希望本文能给更多pythoner普及yield的更多用法，使python的这个特性能够更加多的活跃在大家的代码中。 源PPT和源码可以从这里下载：http://www.dabea">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2017/12/18/1606a1ca476be4ff?w=504&h=66&f=jpeg&s=11538">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2017/12/18/1606a1ca4bf5e89b?w=297&h=72&f=jpeg&s=5931">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2017/12/18/1606a1ca4c0c2aae?w=231&h=67&f=jpeg&s=4661">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2017/12/18/1606a1cad4c30a5f?w=394&h=60&f=jpeg&s=7992">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2017/12/18/1606a1cae0e875d3?w=524&h=179&f=jpeg&s=22192">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2017/12/18/1606a1ca4993ff80?w=513&h=155&f=jpeg&s=17379">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2017/12/18/1606a1ca70a58938?w=475&h=133&f=jpeg&s=18831">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2017/12/18/1606a1ca68f11f11?w=465&h=128&f=jpeg&s=14787">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2017/12/18/1606a1ca845377b7?w=484&h=157&f=jpeg&s=18672">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2017/12/18/1606a1ca85ada3c2?w=738&h=309&f=jpeg&s=38634">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2017/12/18/1606a1ca8a8d27e1?w=562&h=381&f=jpeg&s=43235">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2017/12/18/1606a1ca9907733b?w=661&h=106&f=jpeg&s=16601">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2017/12/18/1606a1caa5d74575?w=545&h=124&f=jpeg&s=15590">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2017/12/18/1606a1caa79f0a94?w=583&h=198&f=jpeg&s=19725">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2017/12/18/1606a1caba80f663?w=563&h=325&f=jpeg&s=53870">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2017/12/18/1606a1cac4000971?w=83&h=123&f=jpeg&s=6465">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2017/12/18/1606a1cacce54e5b?w=540&h=361&f=jpeg&s=47943">
<meta property="og:updated_time" content="2019-06-30T16:42:35.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Python中的携程">
<meta name="twitter:description" content="Coroutine in Python引言: 本文出自David Beazley 的关于协程的PPT，现在笔者将他翻译过来。并整理成文。感谢在协程方面的专家David Beazley， 能给我们这么深入的协程上面的讲座。也希望本文能给更多pythoner普及yield的更多用法，使python的这个特性能够更加多的活跃在大家的代码中。 源PPT和源码可以从这里下载：http://www.dabea">
<meta name="twitter:image" content="https://user-gold-cdn.xitu.io/2017/12/18/1606a1ca476be4ff?w=504&h=66&f=jpeg&s=11538">





  
  
  <link rel="canonical" href="http://lumiaxu.com/2017/12/05/Python中的携程/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Python中的携程 | LumiaXu's Blog</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LumiaXu's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">LumiaXu码字的地方</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lumiaxu.com/2017/12/05/Python中的携程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LumiaXu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LumiaXu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Python中的携程

              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-12-05 15:33:00" itemprop="dateCreated datePublished" datetime="2017-12-05T15:33:00+08:00">2017-12-05</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-01 00:42:35" itemprop="dateModified" datetime="2019-07-01T00:42:35+08:00">2019-07-01</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Coroutine-in-Python"><a href="#Coroutine-in-Python" class="headerlink" title="Coroutine in Python"></a>Coroutine in Python</h1><p><code>引言: 本文出自David Beazley 的关于协程的PPT，现在笔者将他翻译过来。并整理成文。感谢在协程方面的专家David Beazley， 能给我们这么深入的协程上面的讲座。也希望本文能给更多pythoner普及yield的更多用法，使python的这个特性能够更加多的活跃在大家的代码中。</code></p>
<h2 id="源PPT和源码可以从这里下载："><a href="#源PPT和源码可以从这里下载：" class="headerlink" title="源PPT和源码可以从这里下载："></a>源PPT和源码可以从这里下载：</h2><p><a href="http://www.dabeaz.com/coroutines/" target="_blank" rel="noopener">http://www.dabeaz.com/coroutines/</a></p>
<h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><pre><code>1. 什么是协程
2. 协程怎么用
3. 要注意什么
4. 用他们好么</code></pre><h2 id="第一部分：生成器和协程的介绍"><a href="#第一部分：生成器和协程的介绍" class="headerlink" title="第一部分：生成器和协程的介绍"></a>第一部分：生成器和协程的介绍</h2><h3 id="生成器-Generator-的本质和特点"><a href="#生成器-Generator-的本质和特点" class="headerlink" title="生成器(Generator)的本质和特点"></a>生成器(Generator)的本质和特点</h3><p>生成器 是 可以生成一定序列的 <em>函数</em>。
函数可以调用next()方法。</p>
<h3 id="生成器的例子："><a href="#生成器的例子：" class="headerlink" title="生成器的例子："></a>生成器的例子：</h3><ul>
<li><p>例子1: follow.py<br>可以使用生成器完成 tail -f 的功能，也就是跟踪输出的功能。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">follow</span><span class="params">(thefile)</span>:</span></span><br><span class="line">    thefile.seek(<span class="number">0</span>,<span class="number">2</span>)      <span class="comment"># Go to the end of the file</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    	line = thefile.readline()</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> line:</span><br><span class="line">      	time.sleep(<span class="number">0.1</span>)    <span class="comment"># Sleep briefly</span></span><br><span class="line">          <span class="keyword">continue</span></span><br><span class="line">      <span class="keyword">yield</span> line</span><br></pre></td></tr></table></figure>
</li>
<li><p>例子2： 生成器用作程序管道（类似unix pipe）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ps：unix pipe </span><br><span class="line">       A pipeline is a sequence of processes chained together by their standard streams </span><br><span class="line"></span><br><span class="line">标注：unix管道</span><br><span class="line">		一个uinx管道是由标准流链接在一起的一系列流程.</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>pipeline.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grep</span><span class="params">(pattern,lines)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="keyword">if</span> pattern <span class="keyword">in</span> line:</span><br><span class="line">             <span class="keyword">yield</span> line</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">from</span> follow <span class="keyword">import</span> follow</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Set up a processing pipe : tail -f | grep python</span></span><br><span class="line">    logfile  = open(<span class="string">"access-log"</span>)</span><br><span class="line">    loglines = follow(logfile)</span><br><span class="line">    pylines  = grep(<span class="string">"python"</span>,loglines)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Pull results out of the processing pipeline</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> pylines:</span><br><span class="line">        <span class="keyword">print</span> line,</span><br></pre></td></tr></table></figure>

<p>理解pipeline.py<br>在pipeline中，follow函数和grep函数相当于程序链，这样就能链式处理程序。</p>
<h3 id="Yield作为表达【我们开始说协程了-】："><a href="#Yield作为表达【我们开始说协程了-】：" class="headerlink" title="Yield作为表达【我们开始说协程了~】："></a>Yield作为表达【我们开始说协程了~】：</h3><p>grep.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grep</span><span class="params">(pattern)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Looking for %s"</span> % pattern</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"give a value in the coroutines"</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        line = (<span class="keyword">yield</span>)</span><br><span class="line">        <span class="keyword">if</span> pattern <span class="keyword">in</span> line:</span><br><span class="line">            <span class="keyword">print</span> line</span><br><span class="line"><span class="comment"># Example use</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    g = grep(<span class="string">"python"</span>)</span><br><span class="line">    g.next()</span><br><span class="line">    g.send(<span class="string">"Yeah, but no, but yeah, but no"</span>)</span><br><span class="line">    g.send(<span class="string">"A series of tubes"</span>)</span><br><span class="line">    g.send(<span class="string">"python generators rock!"</span>)</span><br></pre></td></tr></table></figure>

<p>yield最重要的问题在于yield的值是多少。</p>
<p>yield的值需要使用coroutine协程这个概念<br>相对于仅仅生成值，函数可以动态处理传送进去的值，而最后值通过yield返回。</p>
<h3 id="协程的执行："><a href="#协程的执行：" class="headerlink" title="协程的执行："></a>协程的执行：</h3><p>协程的执行和生成器的执行很相似。<br>当你初始化一个协程，不会返回任何东西。<br>协程只能响应run和send函数。<br><em>协程的执行依赖run和send函数。</em></p>
<h3 id="协程启动："><a href="#协程启动：" class="headerlink" title="协程启动："></a>协程启动：</h3><p>所有的协程都需要调用.next( )函数。<br>调用的next( )函数将要执行到第一个yield表达式的位置。<br>在yield表达式的位置上，很容易去执行就可以。<br><em>协程使用next()启动。</em></p>
<h3 id="使用协程的修饰器："><a href="#使用协程的修饰器：" class="headerlink" title="使用协程的修饰器："></a>使用协程的修饰器：</h3><p>由【协程启动】中我们知道，启动一个协程需要记得调用next( )来开始协程，而这个启动器容易忘记使用。<br>使用修饰器包一层，来让我们启动协程。<br>【以后所有的协程器都会先有@coroutine</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coroutine</span><span class="params">(func)</span>:</span></span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">			cr = func(*args, **kwargs)</span><br><span class="line">          cr.next()</span><br><span class="line">          <span class="keyword">return</span> cr</span><br><span class="line">	<span class="keyword">return</span> start</span><br><span class="line"></span><br><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grep</span><span class="params">(pattern)</span>:</span></span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<h3 id="关闭一个协程"><a href="#关闭一个协程" class="headerlink" title="关闭一个协程:"></a>关闭一个协程:</h3><p>使用close()来关闭。</p>
<h3 id="使用except捕获协程的关闭close"><a href="#使用except捕获协程的关闭close" class="headerlink" title="使用except捕获协程的关闭close():"></a>使用except捕获协程的关闭close():</h3><p>grepclose.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grep</span><span class="params">(pattern)</span>:</span></span><br><span class="line">		<span class="keyword">print</span> <span class="string">"Looking for %s"</span> % pattern</span><br><span class="line">		<span class="keyword">try</span>:</span><br><span class="line">			<span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">          	line = (<span class="keyword">yield</span>)</span><br><span class="line">              <span class="keyword">if</span> pattern <span class="keyword">in</span> line:</span><br><span class="line">              	<span class="keyword">print</span> line,</span><br><span class="line">		<span class="keyword">except</span> GeneratorExit:</span><br><span class="line">			<span class="keyword">print</span> <span class="string">"Going away.  Goodbye"</span></span><br></pre></td></tr></table></figure>

<p>使用GeneratorExit这个异常类型</p>
<h3 id="抛出一个异常："><a href="#抛出一个异常：" class="headerlink" title="抛出一个异常："></a>抛出一个异常：</h3><p>在一个协程中，可以抛出一个异常</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">	g.throw(RuntimeError,<span class="string">"You're hosed"</span>)</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">      File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">      File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">4</span>, <span class="keyword">in</span> grep</span><br><span class="line">    RuntimeError: Yo<span class="string">u're hosed</span></span><br></pre></td></tr></table></figure>

<p>异常起源于yield表达式<br>可以用常规方法去抓取</p>
<h3 id="一些小tips"><a href="#一些小tips" class="headerlink" title="一些小tips"></a>一些小tips</h3><pre><code>* 尽管有点相似，但是生成器和协程是*两个完全不同的概念*。
* 生成器用来产生序列。
* 协程用来处理序列。
* 很容易产生一些误解。因为协程有的时候用来对进程里面的用来产生迭代对象的生成器作微调。</code></pre><h3 id="生成器不能够同时生成值和接受值"><a href="#生成器不能够同时生成值和接受值" class="headerlink" title="生成器不能够同时生成值和接受值"></a>生成器不能够同时生成值和接受值</h3><pre><code>* 不能往generator里面send东西。
* 协程和迭代器的概念没有关系
* 虽然有一种用法，确实是在一个协程里面生成一些值，但是并不和迭代器有关系。</code></pre><h2 id="第二部分：协程，管道，数据流"><a href="#第二部分：协程，管道，数据流" class="headerlink" title="第二部分：协程，管道，数据流"></a>第二部分：协程，管道，数据流</h2><h3 id="进程管道：如下图所示，一连串进程串起来像管道一样。"><a href="#进程管道：如下图所示，一连串进程串起来像管道一样。" class="headerlink" title="进程管道：如下图所示，一连串进程串起来像管道一样。"></a>进程管道：如下图所示，一连串进程串起来像管道一样。</h3><p><img src="https://user-gold-cdn.xitu.io/2017/12/18/1606a1ca476be4ff?w=504&h=66&f=jpeg&s=11538" alt><br>协程可以用来作为进程管道。<br>你仅仅需要把协程连接在一起，然后通过send()操作传递数据。<br>整个进程管道由三部分组成：</p>
<h3 id="第一部分，管道源-协程源："><a href="#第一部分，管道源-协程源：" class="headerlink" title="第一部分，管道源/协程源："></a>第一部分，管道源/协程源：</h3><p>进程管道需要一个初始的源（一个生产者）。<br>这个初始的源驱动整个管道。<br>管道源不是协程。</p>
<h3 id="第二部分，管道终止-协程终止："><a href="#第二部分，管道终止-协程终止：" class="headerlink" title="第二部分，管道终止/协程终止："></a>第二部分，管道终止/协程终止：</h3><p>管道必须有个终止点。<br>管道终止/协程终止是进程管道的终止点。</p>
<h3 id="例子：以实现tail-f-功能为例子"><a href="#例子：以实现tail-f-功能为例子" class="headerlink" title="例子：以实现tail -f 功能为例子"></a>例子：以实现tail -f 功能为例子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> coroutine <span class="keyword">import</span> coroutine</span><br><span class="line"></span><br><span class="line"><span class="comment"># A data source.  This is not a coroutine, but it sends</span></span><br><span class="line"><span class="comment"># data into one (target)</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">follow</span><span class="params">(thefile, target)</span>:</span></span><br><span class="line">    thefile.seek(<span class="number">0</span>,<span class="number">2</span>)      <span class="comment"># Go to the end of the file</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">         line = thefile.readline()</span><br><span class="line">         <span class="keyword">if</span> <span class="keyword">not</span> line:</span><br><span class="line">             time.sleep(<span class="number">0.1</span>)    <span class="comment"># Sleep briefly</span></span><br><span class="line">             <span class="keyword">continue</span></span><br><span class="line">         target.send(line)</span><br><span class="line"></span><br><span class="line"><span class="comment"># A sink.  A coroutine that receives data</span></span><br><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printer</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">         line = (<span class="keyword">yield</span>)</span><br><span class="line">         <span class="keyword">print</span> line,</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example use</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    f = open(<span class="string">"access-log"</span>)</span><br><span class="line">    follow(f,printer())</span><br></pre></td></tr></table></figure>

<p>分析：第一个follow函数是协程源，第二个printer函数是协程终止。协程源不是一个协程，但是需要传入一个已经初始化完毕的协程。在协程源当中，调用send()。<br><img src="https://user-gold-cdn.xitu.io/2017/12/18/1606a1ca4bf5e89b?w=297&h=72&f=jpeg&s=5931" alt></p>
<h3 id="第三部分，管道过滤器"><a href="#第三部分，管道过滤器" class="headerlink" title="第三部分，管道过滤器:"></a>第三部分，管道过滤器:</h3><p>叫过滤器其实并不贴切，应该叫中间人Intermediate：其两端都是send()函数。<br><img src="https://user-gold-cdn.xitu.io/2017/12/18/1606a1ca4c0c2aae?w=231&h=67&f=jpeg&s=4661" alt><br>(协程的中间层)<br>典型的中间层如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">filter</span><span class="params">(target)</span>:</span>  <span class="comment"># 这个target是传递参数的对象</span></span><br><span class="line">	<span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">		item = (<span class="keyword">yield</span>)  <span class="comment"># 这里用来接收上一个send()传入的value</span></span><br><span class="line">		<span class="comment"># Transform/filter item</span></span><br><span class="line">		<span class="comment"># processing items</span></span><br><span class="line">		<span class="comment"># Send it along to the next stage</span></span><br><span class="line">		target.send(item)  <span class="comment"># 像target传递参数</span></span><br></pre></td></tr></table></figure>

<p>分析可知，中间层需要接受上一个coroutine，也需要往下一个coroutine里面传递值。</p>
<p><em>一个管道过滤器的例子</em><br>从文章中找出具有“python”关键字的句子打印。<br>grep.py: </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grep</span><span class="params">(pattern, target)</span>:</span>  <span class="comment"># 这个target用来接收参数</span></span><br><span class="line">	<span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">		line = (<span class="keyword">yield</span>)  <span class="comment"># 这里用来接收上一个send()传入的value</span></span><br><span class="line">		<span class="comment"># Transform/filter item</span></span><br><span class="line">		<span class="comment"># processing items</span></span><br><span class="line">		<span class="keyword">if</span> pattern <span class="keyword">in</span> line:</span><br><span class="line">			target.send(line)</span><br><span class="line">		<span class="comment"># Send it along to the next stage</span></span><br></pre></td></tr></table></figure>

<p>Hook it up with follow and printer:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">"access-log"</span>)</span><br><span class="line"> follow(f, grep(<span class="string">'python'</span>, printer()))</span><br></pre></td></tr></table></figure>

<p>grep 从中间传入follow，然后printer传入grep。<br><img src="https://user-gold-cdn.xitu.io/2017/12/18/1606a1cad4c30a5f?w=394&h=60&f=jpeg&s=7992" alt></p>
<h3 id="协程和生成器的对比"><a href="#协程和生成器的对比" class="headerlink" title="协程和生成器的对比"></a>协程和生成器的对比</h3><p><img src="https://user-gold-cdn.xitu.io/2017/12/18/1606a1cae0e875d3?w=524&h=179&f=jpeg&s=22192" alt><br>不同处：生成器使用了迭代器拉取数据，协程使用send()压入数据。</p>
<h3 id="变得多分支：（上一个协程发送数据去多个下一段协程）"><a href="#变得多分支：（上一个协程发送数据去多个下一段协程）" class="headerlink" title="变得多分支：（上一个协程发送数据去多个下一段协程）"></a>变得多分支：（上一个协程发送数据去多个下一段协程）</h3><p>图示：<br><img src="https://user-gold-cdn.xitu.io/2017/12/18/1606a1ca4993ff80?w=513&h=155&f=jpeg&s=17379" alt></p>
<p>使用协程，你可以发送数据 给 <em>多个</em> 协程过滤器/协程终了。但是请注意，协程源只是用来传递数据的，过多的在协程源中传递数据是令人困惑并且复杂的。</p>
<p><em>一个例子</em></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@coroutine</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">broadcast</span><span class="params">(targets)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        item = (<span class="keyword">yield</span>)</span><br><span class="line">        <span class="keyword">for</span> target <span class="keyword">in</span> targets:</span><br><span class="line">            target.send(item)</span><br></pre></td></tr></table></figure>

<p>Hook it Up!</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    f = open(<span class="string">"access-log"</span>)</span><br><span class="line">    follow(f,</span><br><span class="line">       broadcast([grep(<span class="string">'python'</span>,printer()),</span><br><span class="line">                  grep(<span class="string">'ply'</span>,printer()),</span><br><span class="line">                  grep(<span class="string">'swig'</span>,printer())])</span><br><span class="line">           )</span><br></pre></td></tr></table></figure>

<p>从文章中分别打印出含有’python‘ ’ply‘ ’swig‘ 关键字的句子。使用了一个协程队列向所有printer协程 送出 接收到的数据。<br>图示：<br><img src="https://user-gold-cdn.xitu.io/2017/12/18/1606a1ca70a58938?w=475&h=133&f=jpeg&s=18831" alt></p>
<p>或者这样Hook them up: </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    f = open(<span class="string">"access-log"</span>)</span><br><span class="line">    p = printer()</span><br><span class="line">    follow(f,</span><br><span class="line">       broadcast([grep(<span class="string">'python'</span>,p),</span><br><span class="line">                  grep(<span class="string">'ply'</span>,p),</span><br><span class="line">                  grep(<span class="string">'swig'</span>,p)])</span><br><span class="line">           )</span><br></pre></td></tr></table></figure>

<p>图示：<br><img src="https://user-gold-cdn.xitu.io/2017/12/18/1606a1ca68f11f11?w=465&h=128&f=jpeg&s=14787" alt></p>
<p><em>为什么我们用协程</em></p>
<ul>
<li>协程相较于迭代器，存在更加强大的数据路由（就像上图的数据流向）的可能。</li>
<li>协程可以将一系列简单的数据处理组件，整合到管道，分支，合并等复杂的布置当中。</li>
<li>但有些限制…【后文会说】<br><em>相对于对象的优势</em></li>
<li>从概念上简单一点：协程就是一个函数，对象要构建整个对象。</li>
<li>从代码执行角度上来说，协程相对要快一些。</li>
</ul>
<h2 id="第三部分：协程，事件分发"><a href="#第三部分：协程，事件分发" class="headerlink" title="第三部分：协程，事件分发"></a>第三部分：协程，事件分发</h2><h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p>协程可以用在写各种各样处理事件流的组件。</p>
<pre><code>介绍一个例子【这个例子会贯穿这个第三部分始终】要求做一个实时的公交车GPS位置监控。编写程序的主要目的是处理一份文件。传统上，使用SAX进行处理。【SAX处理可以减少内存空间的使用，但SAX事件驱动的特性会让它笨重和低效】。</code></pre><h3 id="把SAX和协程组合在一起"><a href="#把SAX和协程组合在一起" class="headerlink" title="把SAX和协程组合在一起"></a>把SAX和协程组合在一起</h3><p>我们可以使用协程分发SAX事件，比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> xml.sax</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventHandler</span><span class="params">(xml.sax.ContentHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,target)</span>:</span></span><br><span class="line">        self.target = target</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">startElement</span><span class="params">(self,name,attrs)</span>:</span></span><br><span class="line">        self.target.send((<span class="string">'start'</span>,(name,attrs._attrs)))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">characters</span><span class="params">(self,text)</span>:</span></span><br><span class="line">        self.target.send((<span class="string">'text'</span>,text))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">endElement</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        self.target.send((<span class="string">'end'</span>,name))</span><br><span class="line"></span><br><span class="line"><span class="comment"># example use</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">from</span> coroutine <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="meta">    @coroutine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printer</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            event = (<span class="keyword">yield</span>)</span><br><span class="line">            <span class="keyword">print</span> event</span><br><span class="line">    xml.sax.parse(<span class="string">"allroutes.xml"</span>,</span><br><span class="line">                  EventHandler(printer()))</span><br></pre></td></tr></table></figure>

<p>解析：整个事件的处理如图所示<br><img src="https://user-gold-cdn.xitu.io/2017/12/18/1606a1ca845377b7?w=484&h=157&f=jpeg&s=18672" alt></p>
<h3 id="【最终的组合】"><a href="#【最终的组合】" class="headerlink" title="【最终的组合】"></a>【最终的组合】</h3><p>比如，把xml改成json最后从中筛选的出固定信息.<br> buses.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buses_to_dicts</span><span class="params">(target)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        event, value = (<span class="keyword">yield</span>)</span><br><span class="line">        <span class="comment"># Look for the start of a &lt;bus&gt; element</span></span><br><span class="line">        <span class="keyword">if</span> event == <span class="string">'start'</span> <span class="keyword">and</span> value[<span class="number">0</span>] == <span class="string">'bus'</span>:</span><br><span class="line">            busdict = &#123;&#125;</span><br><span class="line">            fragments = []</span><br><span class="line">            <span class="comment"># Capture text of inner elements in a dict</span></span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                event, value = (<span class="keyword">yield</span>)</span><br><span class="line">                <span class="keyword">if</span> event == <span class="string">'start'</span>:</span><br><span class="line">                    fragments = []</span><br><span class="line">                <span class="keyword">elif</span> event == <span class="string">'text'</span>:</span><br><span class="line">                    fragments.append(value)</span><br><span class="line">                <span class="keyword">elif</span> event == <span class="string">'end'</span>:</span><br><span class="line">                    <span class="keyword">if</span> value != <span class="string">'bus'</span>:</span><br><span class="line">                        busdict[value] = <span class="string">""</span>.join(fragments)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        target.send(busdict)</span><br><span class="line">                        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>协程的一个有趣的事情是，您可以将初始数据源推送到低级别的语言，而不需要重写所有处理阶段。比如，PPT 中69-73页介绍的，可以通过协程和低级别的语言进行联动，从而达成非常好的优化效果。如Expat模块或者cxmlparse模块。<br>ps: ElementTree具有快速的递增xml句法分析</p>
</blockquote>
<h2 id="第四部分：从数据处理到并发编程"><a href="#第四部分：从数据处理到并发编程" class="headerlink" title="第四部分：从数据处理到并发编程"></a>第四部分：从数据处理到并发编程</h2><h3 id="复习一下上面学的特点："><a href="#复习一下上面学的特点：" class="headerlink" title="复习一下上面学的特点："></a>复习一下上面学的特点：</h3><p>协程有以下特点。</p>
<ul>
<li>协程和生成器非常像。</li>
<li>我们可以用协程，去组合各种简单的小组件。</li>
<li>我们可以使用创建进程管道，数据流图的方法去处理数据。</li>
<li>你可以使用伴有复杂数据处理代码的协程。</li>
</ul>
<h3 id="一个相似的主题："><a href="#一个相似的主题：" class="headerlink" title="一个相似的主题："></a>一个相似的主题：</h3><p>我们往协程内传送数据，向线程内传送数据，也向进程内传送数据。那么，协程自然很容易和线程和分布式系统联系起来。</p>
<h3 id="基础的并发："><a href="#基础的并发：" class="headerlink" title="基础的并发："></a>基础的并发：</h3><p>我们可以通过添加一个额外的层，从而封装协程进入线程或者子进程。这描绘了几个基本的概念。<br><img src="https://user-gold-cdn.xitu.io/2017/12/18/1606a1ca85ada3c2?w=738&h=309&f=jpeg&s=38634" alt></p>
<h3 id="目标！协程-线程【没有蛀牙。"><a href="#目标！协程-线程【没有蛀牙。" class="headerlink" title="目标！协程+线程【没有蛀牙。"></a>目标！协程+线程【没有蛀牙。</h3><p>下面看一个线程的例子。<br>cothread.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threaded</span><span class="params">(target)</span>:</span></span><br><span class="line"><span class="comment"># 第一部分：</span></span><br><span class="line">    messages = Queue()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_target</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            item = messages.get()</span><br><span class="line">            <span class="keyword">if</span> item <span class="keyword">is</span> GeneratorExit:</span><br><span class="line">                target.close()</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                target.send(item)</span><br><span class="line"></span><br><span class="line">    Thread(target=run_target).start()</span><br><span class="line"><span class="comment"># 第二部分：</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            item = (<span class="keyword">yield</span>)</span><br><span class="line">            messages.put(item)</span><br><span class="line">    <span class="keyword">except</span> GeneratorExit:</span><br><span class="line">        messages.put(GeneratorExit)</span><br></pre></td></tr></table></figure>

<p>例子解析：第一部分：先新建一个队列。然后定义一个永久循环的线程；这个线程可以将其中的元素拉出消息队列，然后发送到目标里面。第二部分：接受上面送来的元素，并通过队列，将他们传送进线程里面。其中用到了GeneratorExit ，使得线程可以正确的关闭。</p>
<p>Hook up：cothread.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">import</span> xml.sax</span><br><span class="line">    <span class="keyword">from</span> cosax <span class="keyword">import</span> EventHandler</span><br><span class="line">    <span class="keyword">from</span> buses <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">    xml.sax.parse(<span class="string">"allroutes.xml"</span>, EventHandler(</span><br><span class="line">        buses_to_dicts(</span><br><span class="line">            threaded(</span><br><span class="line">                filter_on_field(<span class="string">"route"</span>, <span class="string">"22"</span>,</span><br><span class="line">              	filter_on_field(<span class="string">"direction"</span>, <span class="string">"North Bound"</span>,</span><br><span class="line">											bus_locations()))))))</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2017/12/18/1606a1ca8a8d27e1?w=562&h=381&f=jpeg&s=43235" alt></p>
<blockquote>
<p>但是：添加线程让这个例子慢了50%</p>
</blockquote>
<h3 id="目标！协程-子进程"><a href="#目标！协程-子进程" class="headerlink" title="目标！协程+子进程"></a>目标！协程+子进程</h3><p>我们知道，进程之间是不共享系统资源的，所以要进行两个子进程之间的通信，我们需要通过一个文件桥接两个协程。<br><img src="https://user-gold-cdn.xitu.io/2017/12/18/1606a1ca9907733b?w=661&h=106&f=jpeg&s=16601" alt></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cPickle <span class="keyword">as</span> pickle</span><br><span class="line"><span class="keyword">from</span> coroutine <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sendto</span><span class="params">(f)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            item = (<span class="keyword">yield</span>)</span><br><span class="line">            pickle.dump(item, f)</span><br><span class="line">            f.flush()</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        f.close()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recvfrom</span><span class="params">(f, target)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            item = pickle.load(f)</span><br><span class="line">            target.send(item)</span><br><span class="line">    <span class="keyword">except</span> EOFError:</span><br><span class="line">        target.close()</span><br><span class="line"><span class="comment"># Example use</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">import</span> xml.sax</span><br><span class="line">    <span class="keyword">from</span> cosax <span class="keyword">import</span> EventHandler</span><br><span class="line">    <span class="keyword">from</span> buses <span class="keyword">import</span> *</span><br><span class="line">    <span class="keyword">import</span> subprocess</span><br><span class="line">    p = subprocess.Popen([<span class="string">'python'</span>, <span class="string">'busproc.py'</span>],</span><br><span class="line">                         stdin=subprocess.PIPE)</span><br><span class="line">    xml.sax.parse(<span class="string">"allroutes.xml"</span>,</span><br><span class="line">                  EventHandler(</span><br><span class="line">                      buses_to_dicts(</span><br><span class="line">                          sendto(p.stdin))))</span><br></pre></td></tr></table></figure>

<p>程序通过sendto()和recvfrom()传递文件。</p>
<h3 id="和环境结合的协程："><a href="#和环境结合的协程：" class="headerlink" title="和环境结合的协程："></a>和环境结合的协程：</h3><p>使用协程，我们可以从一个任务的执行环境中剥离出他的实现。并且，协程就是那个实现。执行环境是你选择的线程，子进程，网络等。</p>
<p><em>需要注意的警告</em>：</p>
<ul>
<li>创建大量的协同程序，线程和进程可能是创建 <em>不可维护</em> 应用程序的一个好方法，并且会减慢你程序的速度。需要学习哪些是良好的使用协程的习惯。</li>
<li>在协程里send()方法需要被适当的同步。</li>
<li>如果你对已经正在执行了的协程使用send()方法，那么你的程序会发生崩溃。如：多个线程发送数据进入同一个协程。</li>
<li>同样的不能创造循环的协程：</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/18/1606a1caa5d74575?w=545&h=124&f=jpeg&s=15590" alt></p>
<ul>
<li>堆栈发送正在构建一种调用堆栈（send()函数不返回，直到目标产生）。</li>
<li>如果调用一个正在发送进程的协程，将会抛出一个错误。</li>
<li>send() 函数不会挂起任何一个协程的执行。</li>
</ul>
<h2 id="第五部分：任务一样的协程"><a href="#第五部分：任务一样的协程" class="headerlink" title="第五部分：任务一样的协程"></a>第五部分：任务一样的协程</h2><h3 id="Task的概念"><a href="#Task的概念" class="headerlink" title="Task的概念"></a>Task的概念</h3><p>在并发编程中，通常将问题细分为“任务”。<br>“任务”有下面几个经典的特点：<br>    * 拥有独立的控制流。<br>    * 拥有内在的状态。<br>    * 可以被安排规划/挂起/恢复。<br>    * 可与其他的任务通信。<br>协程也是任务的一种。</p>
<h3 id="协程是任务的一种："><a href="#协程是任务的一种：" class="headerlink" title="协程是任务的一种："></a>协程是任务的一种：</h3><ol>
<li><p>下面的部分 来告诉你协程有他自己的控制流，这里 if 的控制就是控制流。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grep</span><span class="params">(pattern)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Looking for %s"</span> % pattern</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"give a value in the coroutines"</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        line = (<span class="keyword">yield</span>)</span><br><span class="line">        <span class="keyword">if</span> pattern <span class="keyword">in</span> line:</span><br><span class="line">            <span class="keyword">print</span> line</span><br></pre></td></tr></table></figure>
</li>
<li><p>协程是一个类似任何其他Python函数的语句序列。</p>
</li>
<li><p>协程有他们内在的自己的状态，比如一些变量：其中的pattern和line就算是自己的状态。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grep</span><span class="params">(pattern)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Looking for %s"</span> % pattern</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"give a value in the coroutines"</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        line = (<span class="keyword">yield</span>)</span><br><span class="line">        <span class="keyword">if</span> pattern <span class="keyword">in</span> line:</span><br><span class="line">            <span class="keyword">print</span> line</span><br></pre></td></tr></table></figure>
</li>
<li><p>本地的生存时间和协程的生存时间相同。</p>
</li>
<li><p>很多协程构建了一个可执行的环境。</p>
</li>
<li><p>协程可以互相通信，比如：yield就是用来接受传递的信息，而上一个协程的send( )就是用来向下一个协程。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grep</span><span class="params">(pattern)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Looking for %s"</span> % pattern</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"give a value in the coroutines"</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        line = (<span class="keyword">yield</span>)</span><br><span class="line">        <span class="keyword">if</span> pattern <span class="keyword">in</span> line:</span><br><span class="line">            <span class="keyword">print</span> line</span><br></pre></td></tr></table></figure>
</li>
<li><p>协程可以被挂起，重启，关闭。</p>
<ul>
<li>yield可以挂起执行进程。</li>
<li>send() 用来 重启执行进程。</li>
<li>close()用来终止/关闭进程。</li>
</ul>
</li>
</ol>
<p>总之，一个协程满足以上所有任务(task)的特点，所以协程非常像任务。但是协程不用与任何一个线程或者子进程绑定。</p>
<h2 id="第六部分：操作系统的中断事件。（微嵌课程学的好的同学可以直接跳到这部分的“启示”✌️）"><a href="#第六部分：操作系统的中断事件。（微嵌课程学的好的同学可以直接跳到这部分的“启示”✌️）" class="headerlink" title="第六部分：操作系统的中断事件。（微嵌课程学的好的同学可以直接跳到这部分的“启示”✌️）"></a>第六部分：操作系统的中断事件。（微嵌课程学的好的同学可以直接跳到这部分的“启示”✌️）</h2><h3 id="操作系统的执行（复习微嵌知识）"><a href="#操作系统的执行（复习微嵌知识）" class="headerlink" title="操作系统的执行（复习微嵌知识）"></a>操作系统的执行（复习微嵌知识）</h3><p>当计算机运行时，电脑没有同时运行好几条指令的打算。而无论是处理器，应用程序都不懂多任务处理。所以，操作系统需要去完成多任务的调度。操作系统通过在多个任务中快速切换来实现多任务。</p>
<h3 id="需要解决的问题（还在复习微嵌知识）"><a href="#需要解决的问题（还在复习微嵌知识）" class="headerlink" title="需要解决的问题（还在复习微嵌知识）"></a>需要解决的问题（还在复习微嵌知识）</h3><p>CPU执行的是应用程序，而不是你的操作系统，那<em>没有被CPU执行的操作系统</em>是怎么控制<em>正在运行的应用程序</em>中断的呢。</p>
<h3 id="中断（interrupts）和陷阱（Traps）"><a href="#中断（interrupts）和陷阱（Traps）" class="headerlink" title="中断（interrupts）和陷阱（Traps）"></a>中断（interrupts）和陷阱（Traps）</h3><p>操作系统只能通过两个机制去获得对应用程序的控制：中断和陷阱。<br>    * 中断：和硬件有关的balabala。<br>    * 陷阱：一个软件发出的信号。<br>在两种状况下，CPU都会挂起正在做的，然后执行OS的代码（这个时候，OS的代码成功插入了应用程序的执行），此时，OS来切换了程序。</p>
<h3 id="中断的底层实现（略…码字员微嵌只有70分🤦‍♀️）"><a href="#中断的底层实现（略…码字员微嵌只有70分🤦‍♀️）" class="headerlink" title="中断的底层实现（略…码字员微嵌只有70分🤦‍♀️）"></a>中断的底层实现（略…码字员微嵌只有70分🤦‍♀️）</h3><h3 id="中断的高级表现："><a href="#中断的高级表现：" class="headerlink" title="中断的高级表现："></a>中断的高级表现：</h3><pre><code>* 中断（Traps）使得OS的代码可以实现。
* 在程序运行遇到中断（Traps）时，OS强制在CPU上停止你的程序。
* 程序挂起，然后OS运行。</code></pre><p>表现如下图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/18/1606a1caa79f0a94?w=583&h=198&f=jpeg&s=19725" alt><br>每次中断（Traps）程序都会执行另一个不同的任务。</p>
<h3 id="任务调度（非常简单）："><a href="#任务调度（非常简单）：" class="headerlink" title="任务调度（非常简单）："></a>任务调度（非常简单）：</h3><p>为了执行很多任务，添加一簇任务队列。<br><img src="https://user-gold-cdn.xitu.io/2017/12/18/1606a1caba80f663?w=563&h=325&f=jpeg&s=53870" alt></p>
<h3 id="启示（很重要）："><a href="#启示（很重要）：" class="headerlink" title="启示（很重要）："></a>启示（很重要）：</h3><p>BB了这么多微嵌的内容，得到的是什么结论呢。类比任务调度，协程中yield声明可以理解为中断（Traps）。当一个生成器函数碰到了yield声明，那函数将立即挂起。而执行被传给生成器函数运行的任何代码。如果你把yield声明看成了一个中断，那么你就可以组件一个多任务执行的操作系统了。</p>
<h2 id="第七部分：让我们建一个操作系统。【起飞了，请握好扶手"><a href="#第七部分：让我们建一个操作系统。【起飞了，请握好扶手" class="headerlink" title="第七部分：让我们建一个操作系统。【起飞了，请握好扶手"></a>第七部分：让我们建一个操作系统。【起飞了，请握好扶手</h2><h3 id="目标：满足以下条件建成一个操作系统。"><a href="#目标：满足以下条件建成一个操作系统。" class="headerlink" title="目标：满足以下条件建成一个操作系统。"></a>目标：满足以下条件建成一个操作系统。</h3><pre><code>1. 用纯python语句。
2. 不用线程。
3. 不用子进程。
4. 使用生成器和协程器。</code></pre><h3 id="我们用python去构建操作系统的一些动机："><a href="#我们用python去构建操作系统的一些动机：" class="headerlink" title="我们用python去构建操作系统的一些动机："></a>我们用python去构建操作系统的一些动机：</h3><pre><code>* 尤其在存在线程锁(GIL)的条件下，在线程间切换会变得非常重要。我要高并发！
* 不阻塞和异步I/O。我要高并发！
* 在实战中可能会遇到：服务器要同时处理上千条客户端的连接。我要高并发！
* 大量的工作 致力于实现 事件驱动 或者说 响应式模型。我要组件化！
* 综上，python构建操作系统，有利于了解现在高并发，组件化的趋势。</code></pre><h4 id="第一步：定义任务"><a href="#第一步：定义任务" class="headerlink" title="第一步：定义任务"></a>第一步：定义任务</h4><p>定义一个任务类：任务像一个协程的壳，协程函数传入target；任务类仅仅有一个run()函数。<br>pyos1.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Step 1: Tasks</span></span><br><span class="line"><span class="comment"># This object encapsulates a running task.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span><span class="params">(object)</span>:</span></span><br><span class="line">    taskid = <span class="number">0</span> <span class="comment"># 所有task对象会共享这个值。不熟悉的朋友请补一下类的知识</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,target)</span>:</span></span><br><span class="line">        Task.taskid += <span class="number">1</span></span><br><span class="line">        self.tid     = Task.taskid   <span class="comment"># Task ID</span></span><br><span class="line">        self.target  = target        <span class="comment"># Target coroutine</span></span><br><span class="line">        self.sendval = <span class="literal">None</span>          <span class="comment"># Value to send</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Run a task until it hits the next yield statement</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.target.send(self.sendval)</span><br></pre></td></tr></table></figure>

<p>任务类的执行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># A simple generator/coroutine function</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Part 1"</span></span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Part 2"</span></span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line"></span><br><span class="line">    t1 = Task(foo())</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Running foo()"</span></span><br><span class="line">    t1.run()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Resuming foo()"</span></span><br><span class="line">    t1.run()</span><br></pre></td></tr></table></figure>

<p>在foo中，yield就像中断（Traps）一样，每次执行run()，任务就会执行到下一个yield（一个中断）。</p>
<h4 id="第二步：构建调度者"><a href="#第二步：构建调度者" class="headerlink" title="第二步：构建调度者"></a>第二步：构建调度者</h4><p>下面是调度者类，两个属性分别是Task队列和task_id与Task类对应的map。schedule()向队列里面添加Task。new()用来初始化目标函数（协程函数），将目标函数包装在Task，进而装入Scheduler。最后mainloop会从队列里面拉出task然后执行到task的target函数的yield为止，执行完以后再把task放回队列。这样下一次会从下一个yield开始执行。<br>pyos2.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scheduler</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.ready   = Queue()   </span><br><span class="line">        self.taskmap = &#123;&#125;        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new</span><span class="params">(self,target)</span>:</span></span><br><span class="line">        newtask = Task(target)</span><br><span class="line">        self.taskmap[newtask.tid] = newtask</span><br><span class="line">        self.schedule(newtask)</span><br><span class="line">        <span class="keyword">return</span> newtask.tid</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">schedule</span><span class="params">(self,task)</span>:</span></span><br><span class="line">        self.ready.put(task)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mainloop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.taskmap:</span><br><span class="line">            task = self.ready.get()</span><br><span class="line">            result = task.run()</span><br><span class="line">            self.schedule(task)</span><br></pre></td></tr></table></figure>

<p>下面是一个执行的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># === Example ===</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># Two tasks</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"I'm foo"</span></span><br><span class="line">            <span class="keyword">yield</span></span><br><span class="line">            <span class="keyword">print</span> <span class="string">"I am foo 2"</span></span><br><span class="line">            <span class="keyword">yield</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"I'm bar"</span></span><br><span class="line">            <span class="keyword">yield</span></span><br><span class="line">            <span class="keyword">print</span> <span class="string">"i am bar 2"</span></span><br><span class="line">            <span class="keyword">yield</span>       </span><br><span class="line">    <span class="comment"># Run them</span></span><br><span class="line">    sched = Scheduler()</span><br><span class="line">    sched.new(foo())</span><br><span class="line">    sched.new(bar())</span><br><span class="line">    sched.mainloop()</span><br></pre></td></tr></table></figure>

<p>执行结果，可以发现两个task之间任务是交替的，并且以yield作为中断点。每当执行撞到yield（中断点）之后，Scheduler对Tasks做重新的规划。下图是两个循环。<br>上述执行的结果：<br><img src="https://user-gold-cdn.xitu.io/2017/12/18/1606a1cac4000971?w=83&h=123&f=jpeg&s=6465" alt></p>
<h4 id="第三步：确定任务的停止条件"><a href="#第三步：确定任务的停止条件" class="headerlink" title="第三步：确定任务的停止条件"></a>第三步：确定任务的停止条件</h4><p>如果，target函数里面不是死循环，那么上面的代码就会出错。所以我们对Scheduler做改进。添加一个从任务队列中删除的操作，和对于StopIteration的验证。<br>【对scheduler做改进的原因是任务的性质：可以被安排规划/挂起/恢复。】</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scheduler</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">			...     </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new</span><span class="params">(self,target)</span>:</span></span><br><span class="line">			...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">schedule</span><span class="params">(self,task)</span>:</span></span><br><span class="line">			...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exit</span><span class="params">(self,task)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Task %d terminated"</span> % task.tid</span><br><span class="line">        <span class="keyword">del</span> self.taskmap[task.tid]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mainloop</span><span class="params">(self)</span>:</span></span><br><span class="line">         <span class="keyword">while</span> self.taskmap:</span><br><span class="line">            task = self.ready.get()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                result = task.run()</span><br><span class="line">            <span class="keyword">except</span> StopIteration:</span><br><span class="line">                self.exit(task)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            self.schedule(task)</span><br></pre></td></tr></table></figure>

<h4 id="第四步：添加系统调用基类。"><a href="#第四步：添加系统调用基类。" class="headerlink" title="第四步：添加系统调用基类。"></a>第四步：添加系统调用基类。</h4><p>在OS中，中断是应用程序请求系统服务的方式。在我们的代码中，OS是调度者（scheduler），而中断是yield。为了请求调度者服务，任务需要带值使用yield声明。<br>pyos4.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scheduler</span><span class="params">(object)</span>:</span></span><br><span class="line">	  ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mainloop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.taskmap:   <span class="comment"># 1</span></span><br><span class="line">            task = self.ready.get() </span><br><span class="line">            <span class="keyword">try</span>:				 <span class="comment"># 2</span></span><br><span class="line">                result = task.run()</span><br><span class="line">                <span class="keyword">if</span> isinstance(result, SystemCall):</span><br><span class="line">                    result.task = task</span><br><span class="line">                    result.sched = self</span><br><span class="line">                    result.handle()</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">except</span> StopIteration:</span><br><span class="line">                self.exit(task)</span><br><span class="line">                <span class="keyword">continue</span> </span><br><span class="line">            self.schedule(task) <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SystemCall</span><span class="params">(object)</span>:</span> <span class="comment"># 4</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>代码解析：<br>    1. 如果taskmap里面存在task，就从ready队列里面拿任务出来，如果没有就结束mainloop。<br>    2. 【就是传说中的系统调运部分】ready队列里面的task被拿出来以后，执行task，返回一个result对象，并初始化这个result对象。如果队列里面的task要停止迭代了（终止yield这个过程）就从队列里删除这个任务。<br>    3. 最后再通过schedule函数把执行后的task放回队列里面。<br>    4. 系统调用基类，之后所有的系统调用都要从这个基类继承。</p>
<h4 id="第4-5步：添加第一个系统调用"><a href="#第4-5步：添加第一个系统调用" class="headerlink" title="第4.5步：添加第一个系统调用"></a>第4.5步：添加第一个系统调用</h4><p>这个系统调用想返回任务的id。<br>Task的sendval属性就像一个系统调用的返回值。当task重新运行的是后，sendval将会传入这个系统调用。<br>pyos4.py </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetTid</span><span class="params">(SystemCall)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="comment"># 把task的id传给task的返回参数：</span></span><br><span class="line">        self.task.sendval = self.task.tid  </span><br><span class="line">		<span class="comment"># 再把task给放入Scheduler的队列里面</span></span><br><span class="line">        self.sched.schedule(self.task)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span><span class="params">(object)</span>:</span></span><br><span class="line">	  ...</span><br><span class="line">    <span class="comment"># Run a task until it hits the next yield statement</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.target.send(self.sendval)</span><br></pre></td></tr></table></figure>

<p>进行最后的调用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">        mytid = <span class="keyword">yield</span> GetTid()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">5</span>):</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"I'm foo"</span>, mytid</span><br><span class="line">            <span class="keyword">yield</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">        mytid = <span class="keyword">yield</span> GetTid()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">10</span>):</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"I'm bar"</span>, mytid</span><br><span class="line">            <span class="keyword">yield</span></span><br><span class="line"></span><br><span class="line">    sched = Scheduler()</span><br><span class="line">    sched.new(foo())</span><br><span class="line">    sched.new(bar())</span><br><span class="line">    sched.mainloop()</span><br></pre></td></tr></table></figure>

<p><em>理解这段代码的前提：</em>（非常重要）<br>    1. send()函数有返回值的，返回值是yield表达式右边的值。在本段代码中，result的返回值是yield GetTid()的GetTid的实例或者是yield后面的None。<br>    2. 执行send(sendval)以后，sendval被传入了yield表达式。并赋给了mytid，返回GetTid()给ruselt。</p>
<p>执行顺序：<br>    先创建一个调度者(Scheduler)，然后在调度者里面添加两个协程函数：foo()， bar()，最后触发mainloop进行协程的调度执行。</p>
<p>系统调用原理：<br>    系统调用是基于系统调用类实现的，如GetTid类，其目的是传出自己的tid。传出自己的tid之后，再将task放回队列。</p>
<h4 id="第五步：任务管理"><a href="#第五步：任务管理" class="headerlink" title="第五步：任务管理"></a>第五步：任务管理</h4><p>上面我们搞定了一个GetTid系统调用。我们现在搞定更多的系统调用：<br>    * 创建一个新的任务。<br>    * 杀掉一个已经存在的任务。<br>    * 等待一个任务结束。<br>这些细小的相同的操作会与线程，进程配合。</p>
<pre><code>1. *创建一个新的系统调用*：通过系统调用加入一个task。</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create a new task</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewTask</span><span class="params">(SystemCall)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,target)</span>:</span></span><br><span class="line">        self.target = target</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(self)</span>:</span></span><br><span class="line">        tid = self.sched.new(self.target)</span><br><span class="line">        self.task.sendval = tid</span><br><span class="line">        self.sched.schedule(self.task)</span><br></pre></td></tr></table></figure>

<pre><code>2. *杀掉一个系统调用*：通过系统调用杀掉一个task。</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KillTask</span><span class="params">(SystemCall)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, tid)</span>:</span></span><br><span class="line">        self.tid = tid</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(self)</span>:</span></span><br><span class="line">        task = self.sched.taskmap.get(self.tid, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> task:</span><br><span class="line">            task.target.close()</span><br><span class="line">            self.task.sendval = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.task.sendval = <span class="literal">False</span></span><br><span class="line">        self.sched.schedule(self.task)</span><br></pre></td></tr></table></figure>

<pre><code>3. 进程等待：需要大幅度改进Scheduler。</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scheduler</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">			...</span><br><span class="line">        <span class="comment"># Tasks waiting for other tasks to exit</span></span><br><span class="line">        self.exit_waiting = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new</span><span class="params">(self, target)</span>:</span></span><br><span class="line">			...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exit</span><span class="params">(self, task)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Task %d terminated"</span> % task.tid</span><br><span class="line">        <span class="keyword">del</span> self.taskmap[task.tid]</span><br><span class="line">        <span class="comment"># Notify other tasks waiting for exit</span></span><br><span class="line">        <span class="keyword">for</span> task <span class="keyword">in</span> self.exit_waiting.pop(task.tid, []):</span><br><span class="line">            self.schedule(task)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">waitforexit</span><span class="params">(self, task, waittid)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> waittid <span class="keyword">in</span> self.taskmap:</span><br><span class="line">            self.exit_waiting.setdefault(waittid, []).append(task)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">schedule</span><span class="params">(self, task)</span>:</span></span><br><span class="line">			...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mainloop</span><span class="params">(self)</span>:</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<p>exit_waiting 是用来暂时存放要退出task的地方。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaitTask</span><span class="params">(SystemCall)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, tid)</span>:</span></span><br><span class="line">        self.tid = tid</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(self)</span>:</span></span><br><span class="line">        result = self.sched.waitforexit(self.task, self.tid)</span><br><span class="line">        self.task.sendval = result</span><br><span class="line">        <span class="comment"># If waiting for a non-existent task,</span></span><br><span class="line">        <span class="comment"># return immediately without waiting</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> result:</span><br><span class="line">            self.sched.schedule(self.task)</span><br></pre></td></tr></table></figure>

<p>设计讨论：<br>    * 在任务中引用另一个任务的唯一办法 是 使用scheduler分配给它的任务ID。<br>    * 上述准则是一个安全的封装策略。<br>    * 这个准则让任务保持独立，不与内核混淆在一起。<br>    * 这个准则能让所有的任务都被scheduler管理的好好的。</p>
<h3 id="网络服务器的搭建："><a href="#网络服务器的搭建：" class="headerlink" title="网络服务器的搭建："></a>网络服务器的搭建：</h3><p>现在已经完成了：<br>    * 多任务。<br>    * 开启新的进程。<br>    * 进行新任务的管理。<br>这些特点都非常符合一个web服务器的各种特点。下面做一个Echo Server的尝试。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyos6 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_client</span><span class="params">(client, addr)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Connection from"</span>, addr</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = client.recv(<span class="number">65536</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        client.send(data)</span><br><span class="line">    client.close()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Client closed"</span></span><br><span class="line">    <span class="keyword">yield</span>  <span class="comment"># Make the function a generator/coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">server</span><span class="params">(port)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Server starting"</span></span><br><span class="line">    sock = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">    sock.bind((<span class="string">""</span>, port))</span><br><span class="line">    sock.listen(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        client, addr = sock.accept()</span><br><span class="line">        <span class="keyword">yield</span> NewTask(handle_client(client, addr))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">alive</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"I'm alive!"</span></span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line">sched = Scheduler()</span><br><span class="line">sched.new(alive())</span><br><span class="line">sched.new(server(<span class="number">45000</span>))</span><br><span class="line">sched.mainloop()</span><br></pre></td></tr></table></figure>

<p>但问题是这个网络服务器是I / O阻塞的。整个python的解释器需要挂起，一直到I/O操作结束。</p>
<h2 id="非阻塞的I-O"><a href="#非阻塞的I-O" class="headerlink" title="非阻塞的I/O"></a>非阻塞的I/O</h2><p>先额外介绍一个叫Select的模块。select模块可以用来监视一组socket链接的活跃状态。用法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">reading = []    <span class="comment"># List of sockets waiting for read</span></span><br><span class="line">writing = []    <span class="comment"># List of sockets waiting for write</span></span><br><span class="line"><span class="comment"># Poll for I/O activity</span></span><br><span class="line"></span><br><span class="line">r,w,e = select.select(reading,writing,[],timeout)</span><br><span class="line">    <span class="comment"># r is list of sockets with incoming data</span></span><br><span class="line">    <span class="comment"># w is list of sockets ready to accept outgoing data</span></span><br><span class="line">    <span class="comment"># e is list of sockets with an error state</span></span><br></pre></td></tr></table></figure>

<p>下面实现一个非阻塞I/O的网络服务器，所用的思想就是之前所实现的Task waiting 思想。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scheduler</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		  ...</span><br><span class="line">        <span class="comment"># I/O waiting</span></span><br><span class="line">        self.read_waiting = &#123;&#125;</span><br><span class="line">        self.write_waiting = &#123;&#125;</span><br><span class="line">	  ...</span><br><span class="line">    <span class="comment"># I/O waiting</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">waitforread</span><span class="params">(self, task, fd)</span>:</span></span><br><span class="line">        self.read_waiting[fd] = task</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">waitforwrite</span><span class="params">(self, task, fd)</span>:</span></span><br><span class="line">        self.write_waiting[fd] = task</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">iopoll</span><span class="params">(self, timeout)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.read_waiting <span class="keyword">or</span> self.write_waiting:</span><br><span class="line">            r, w, e = select.select(self.read_waiting,</span><br><span class="line">                                    self.write_waiting, </span><br><span class="line">												[], timeout)</span><br><span class="line">            <span class="keyword">for</span> fd <span class="keyword">in</span> r:</span><br><span class="line">					self.schedule(self.read_waiting.pop(fd))</span><br><span class="line">            <span class="keyword">for</span> fd <span class="keyword">in</span> w:</span><br><span class="line">					self.schedule(self.write_waiting.pop(fd))</span><br></pre></td></tr></table></figure>

<p>源码解析：<strong>init</strong>里面的是两个字典。用来存储阻塞的IO的任务。waitforread()和waitforwrite()将需要等待写入和等待读取的task放在dict里面。这里的iopoll()：使用select()去决定使用哪个文件描述器，并且能够不阻塞任意一个和I/O才做有关系的任务。poll这个东西也可以放在mainloop里面，但是这样会带来线性的开销增长。<br>详情请见：<a href="https://www.cnblogs.com/alex3714/p/4372426.html" target="_blank" rel="noopener">Python Select 解析 - 金角大王 - 博客园</a></p>
<p>添加新的系统调用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Wait for a task to exit</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaitTask</span><span class="params">(SystemCall)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, tid)</span>:</span></span><br><span class="line">        self.tid = tid</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(self)</span>:</span></span><br><span class="line">        result = self.sched.waitforexit(self.task, self.tid)</span><br><span class="line">        self.task.sendval = result</span><br><span class="line">        <span class="comment"># If waiting for a non-existent task,</span></span><br><span class="line">        <span class="comment"># return immediately without waiting</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> result:</span><br><span class="line">            self.sched.schedule(self.task)</span><br><span class="line"><span class="comment"># Wait for reading</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadWait</span><span class="params">(SystemCall)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, f)</span>:</span></span><br><span class="line">        self.f = f</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(self)</span>:</span></span><br><span class="line">        fd = self.f.fileno()</span><br><span class="line">        self.sched.waitforread(self.task, fd)</span><br><span class="line"><span class="comment"># Wait for writing</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WriteWait</span><span class="params">(SystemCall)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, f)</span>:</span></span><br><span class="line">        self.f = f</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(self)</span>:</span></span><br><span class="line">        fd = self.f.fileno()</span><br><span class="line">        self.sched.waitforwrite(self.task, fd)</span><br></pre></td></tr></table></figure>

<p>更多请见开头那个连接里面的代码：pyos8.py</p>
<p>这样我们就完成了一个多任务处理的OS。这个OS可以并发执行，可以创建、销毁、等待任务。任务可以进行I/O操作。并且最后我们实现了并发服务器。</p>
<h2 id="第八部分：协程栈的一些问题的研究。"><a href="#第八部分：协程栈的一些问题的研究。" class="headerlink" title="第八部分：协程栈的一些问题的研究。"></a>第八部分：协程栈的一些问题的研究。</h2><h3 id="我们可能在使用yield的时候会遇到一些问题："><a href="#我们可能在使用yield的时候会遇到一些问题：" class="headerlink" title="我们可能在使用yield的时候会遇到一些问题："></a>我们可能在使用yield的时候会遇到一些问题：</h3><p>先来看一段示例代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Accept</span><span class="params">(sock)</span>:</span></span><br><span class="line">      <span class="keyword">yield</span> ReadWait(sock)</span><br><span class="line">      <span class="keyword">return</span> sock.accept()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">server</span><span class="params">(port)</span>:</span></span><br><span class="line">		<span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">  		client,addr = Accept(sock)</span><br><span class="line">      	<span class="keyword">yield</span> NewTask(handle_client(client,addr))</span><br></pre></td></tr></table></figure>

<p>这种情况下，server()函数里面的有调用Accept()，但是accept函数里面的yield不起作用。这是因为yield只能在函数栈的最顶层挂起一个协程。你也不能够把yield写进库函数里面。<br>【这个限制是Stackless Python要解决的问题之一。</p>
<p>解决这个只能在函数栈顶挂起协程的解决方法。<br>    * 有且只有一种方法，能够创建可挂起的子协程和函数。<br>    * 但是，创建可挂起的子协程和函数需要通过我们之前所说的Task Scheduler本身。<br>    * 我们必须严格遵守yield声明。<br>    * 我们需要使用一种 -奇淫巧技- 叫做Trampolining（蹦床）。</p>
<h3 id="让我们来看看这个叫蹦床的奇淫巧技。"><a href="#让我们来看看这个叫蹦床的奇淫巧技。" class="headerlink" title="让我们来看看这个叫蹦床的奇淫巧技。"></a>让我们来看看这个叫蹦床的奇淫巧技。</h3><p>代码：trampoline.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="comment"># A function that calls a subroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    r = <span class="keyword">yield</span> add(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">print</span> r</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">    m = main()</span><br><span class="line">    <span class="comment"># An example of a "trampoline"</span></span><br><span class="line">    sub = m.send(<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">    result = sub.send(<span class="literal">None</span>)</span><br><span class="line">    m.send(result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># execute:</span></span><br><span class="line">run()</span><br></pre></td></tr></table></figure>

<p>整个控制流如下：<br><img src="https://user-gold-cdn.xitu.io/2017/12/18/1606a1cacce54e5b?w=540&h=361&f=jpeg&s=47943" alt></p>
<p>我们看到，上图中左侧为统一的scheduler，如果我们想调用一个子线程，我们都用通过上面的scheduler进行调度。</p>
<h3 id="控制流："><a href="#控制流：" class="headerlink" title="控制流："></a>控制流：</h3><p>控制过程：<br>scheduler -&gt; subroutine_1 -&gt; scheduler -&gt; subroutine_2 -&gt; scheduler -&gt; subroutine_1<br>就像蹦床（trampolining）一样，所有的子进程调度都要先返回scheduler，再进行下一步。【有点像汽车换挡。</p>
<p>而不是：<br>-scheduler -&gt; subroutine_1  -&gt; subroutine_2  -&gt; subroutine_1-<br><em>这种直接栈式的子协程调度是不被允许的。</em></p>
<h2 id="第九部分：最后的一些话。"><a href="#第九部分：最后的一些话。" class="headerlink" title="第九部分：最后的一些话。"></a>第九部分：最后的一些话。</h2><h3 id="更加深远的一些话题。"><a href="#更加深远的一些话题。" class="headerlink" title="更加深远的一些话题。"></a>更加深远的一些话题。</h3><p>有很多更加深远的话题值得我们去讨论。其实在上面的套路里面都说了一些。<br>    * 在task之间的通信。<br>    * 处理阻塞的一些操作：比如和数据库的一些链接。<br>    * 多进程的协程和多线程的协程。<br>    * 异常处理。</p>
<h3 id="让我们对yield一点小尊重："><a href="#让我们对yield一点小尊重：" class="headerlink" title="让我们对yield一点小尊重："></a>让我们对yield一点小尊重：</h3><p>Python 的生成器比很多人想象的有用的多。生成器可以：</p>
<pre><code>* 定制可迭代对象。
* 处理程序管道和数据流。【第二部分提到】
* 事物处理。【第三部分提到的和SAX结合的事务处理】
* 合作的多任务处理【第四部分提到的Task，子进程子线程合作】</code></pre><h3 id="在下列三种蛀牙的情况下我们可以想起来，使用yield。"><a href="#在下列三种蛀牙的情况下我们可以想起来，使用yield。" class="headerlink" title="在下列三种蛀牙的情况下我们可以想起来，使用yield。"></a>在下列三种蛀牙的情况下我们可以想起来，使用yield。</h3><pre><code>* 迭代器：要产生数据。
* 接受数据/消息：消费数据。
* 一个中断：在合作性的多任务里面。</code></pre><p>千万不要一个函数里面包含两个或多个以上的功能，比如函数是generator就是generator，是一个coroutine就是一个coroutin。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>感谢大家阅读。我是LumiaXu，现在就职于商汤科技，是一名实习研究员。如果大家想和我联系，请联系这个邮箱： <a href="mailto:177283052@qq.com" target="_blank" rel="noopener">177283052@qq.com</a>。</p>
<p>如果你想了解更多，请访问原作者的网站：<br><a href="http://www.dabeaz.com" target="_blank" rel="noopener">http://www.dabeaz.com</a></p>
<p>#python/coroutine#</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        
          
        
        <div class="post-tags">
          
            <a href="/tags/协程/" rel="tag"># 协程</a>
          
            <a href="/tags/Python/" rel="tag"># Python</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/06/30/重建日志/" rel="prev" title="重建小记：我回来了">
                重建小记：我回来了 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">LumiaXu</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">2</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">2</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/xrtdkr" title="GitHub &rarr; https://github.com/xrtdkr" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="/xr19960722@gmail.com" title="E-Mail &rarr; xr19960722@gmail.com"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://www.weibo.com/p/1005052835263950/" title="Weibo &rarr; https://www.weibo.com/p/1005052835263950/" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://www.instagram.com/lumiaxu/" title="Instagram &rarr; https://www.instagram.com/lumiaxu/" rel="noopener" target="_blank"><i class="fa fa-fw fa-instagram"></i>Instagram</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Coroutine-in-Python"><span class="nav-number">1.</span> <span class="nav-text">Coroutine in Python</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#源PPT和源码可以从这里下载："><span class="nav-number">1.1.</span> <span class="nav-text">源PPT和源码可以从这里下载：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#问题："><span class="nav-number">1.2.</span> <span class="nav-text">问题：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第一部分：生成器和协程的介绍"><span class="nav-number">1.3.</span> <span class="nav-text">第一部分：生成器和协程的介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#生成器-Generator-的本质和特点"><span class="nav-number">1.3.1.</span> <span class="nav-text">生成器(Generator)的本质和特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#生成器的例子："><span class="nav-number">1.3.2.</span> <span class="nav-text">生成器的例子：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Yield作为表达【我们开始说协程了-】："><span class="nav-number">1.3.3.</span> <span class="nav-text">Yield作为表达【我们开始说协程了~】：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#协程的执行："><span class="nav-number">1.3.4.</span> <span class="nav-text">协程的执行：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#协程启动："><span class="nav-number">1.3.5.</span> <span class="nav-text">协程启动：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用协程的修饰器："><span class="nav-number">1.3.6.</span> <span class="nav-text">使用协程的修饰器：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关闭一个协程"><span class="nav-number">1.3.7.</span> <span class="nav-text">关闭一个协程:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用except捕获协程的关闭close"><span class="nav-number">1.3.8.</span> <span class="nav-text">使用except捕获协程的关闭close():</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#抛出一个异常："><span class="nav-number">1.3.9.</span> <span class="nav-text">抛出一个异常：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一些小tips"><span class="nav-number">1.3.10.</span> <span class="nav-text">一些小tips</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#生成器不能够同时生成值和接受值"><span class="nav-number">1.3.11.</span> <span class="nav-text">生成器不能够同时生成值和接受值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第二部分：协程，管道，数据流"><span class="nav-number">1.4.</span> <span class="nav-text">第二部分：协程，管道，数据流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程管道：如下图所示，一连串进程串起来像管道一样。"><span class="nav-number">1.4.1.</span> <span class="nav-text">进程管道：如下图所示，一连串进程串起来像管道一样。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第一部分，管道源-协程源："><span class="nav-number">1.4.2.</span> <span class="nav-text">第一部分，管道源/协程源：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第二部分，管道终止-协程终止："><span class="nav-number">1.4.3.</span> <span class="nav-text">第二部分，管道终止/协程终止：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#例子：以实现tail-f-功能为例子"><span class="nav-number">1.4.4.</span> <span class="nav-text">例子：以实现tail -f 功能为例子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第三部分，管道过滤器"><span class="nav-number">1.4.5.</span> <span class="nav-text">第三部分，管道过滤器:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#协程和生成器的对比"><span class="nav-number">1.4.6.</span> <span class="nav-text">协程和生成器的对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#变得多分支：（上一个协程发送数据去多个下一段协程）"><span class="nav-number">1.4.7.</span> <span class="nav-text">变得多分支：（上一个协程发送数据去多个下一段协程）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第三部分：协程，事件分发"><span class="nav-number">1.5.</span> <span class="nav-text">第三部分：协程，事件分发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#事件处理"><span class="nav-number">1.5.1.</span> <span class="nav-text">事件处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#把SAX和协程组合在一起"><span class="nav-number">1.5.2.</span> <span class="nav-text">把SAX和协程组合在一起</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#【最终的组合】"><span class="nav-number">1.5.3.</span> <span class="nav-text">【最终的组合】</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第四部分：从数据处理到并发编程"><span class="nav-number">1.6.</span> <span class="nav-text">第四部分：从数据处理到并发编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#复习一下上面学的特点："><span class="nav-number">1.6.1.</span> <span class="nav-text">复习一下上面学的特点：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一个相似的主题："><span class="nav-number">1.6.2.</span> <span class="nav-text">一个相似的主题：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基础的并发："><span class="nav-number">1.6.3.</span> <span class="nav-text">基础的并发：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#目标！协程-线程【没有蛀牙。"><span class="nav-number">1.6.4.</span> <span class="nav-text">目标！协程+线程【没有蛀牙。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#目标！协程-子进程"><span class="nav-number">1.6.5.</span> <span class="nav-text">目标！协程+子进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#和环境结合的协程："><span class="nav-number">1.6.6.</span> <span class="nav-text">和环境结合的协程：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第五部分：任务一样的协程"><span class="nav-number">1.7.</span> <span class="nav-text">第五部分：任务一样的协程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Task的概念"><span class="nav-number">1.7.1.</span> <span class="nav-text">Task的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#协程是任务的一种："><span class="nav-number">1.7.2.</span> <span class="nav-text">协程是任务的一种：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第六部分：操作系统的中断事件。（微嵌课程学的好的同学可以直接跳到这部分的“启示”✌️）"><span class="nav-number">1.8.</span> <span class="nav-text">第六部分：操作系统的中断事件。（微嵌课程学的好的同学可以直接跳到这部分的“启示”✌️）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#操作系统的执行（复习微嵌知识）"><span class="nav-number">1.8.1.</span> <span class="nav-text">操作系统的执行（复习微嵌知识）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#需要解决的问题（还在复习微嵌知识）"><span class="nav-number">1.8.2.</span> <span class="nav-text">需要解决的问题（还在复习微嵌知识）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#中断（interrupts）和陷阱（Traps）"><span class="nav-number">1.8.3.</span> <span class="nav-text">中断（interrupts）和陷阱（Traps）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#中断的底层实现（略…码字员微嵌只有70分🤦‍♀️）"><span class="nav-number">1.8.4.</span> <span class="nav-text">中断的底层实现（略…码字员微嵌只有70分🤦‍♀️）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#中断的高级表现："><span class="nav-number">1.8.5.</span> <span class="nav-text">中断的高级表现：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#任务调度（非常简单）："><span class="nav-number">1.8.6.</span> <span class="nav-text">任务调度（非常简单）：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#启示（很重要）："><span class="nav-number">1.8.7.</span> <span class="nav-text">启示（很重要）：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第七部分：让我们建一个操作系统。【起飞了，请握好扶手"><span class="nav-number">1.9.</span> <span class="nav-text">第七部分：让我们建一个操作系统。【起飞了，请握好扶手</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#目标：满足以下条件建成一个操作系统。"><span class="nav-number">1.9.1.</span> <span class="nav-text">目标：满足以下条件建成一个操作系统。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#我们用python去构建操作系统的一些动机："><span class="nav-number">1.9.2.</span> <span class="nav-text">我们用python去构建操作系统的一些动机：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#第一步：定义任务"><span class="nav-number">1.9.2.1.</span> <span class="nav-text">第一步：定义任务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第二步：构建调度者"><span class="nav-number">1.9.2.2.</span> <span class="nav-text">第二步：构建调度者</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第三步：确定任务的停止条件"><span class="nav-number">1.9.2.3.</span> <span class="nav-text">第三步：确定任务的停止条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第四步：添加系统调用基类。"><span class="nav-number">1.9.2.4.</span> <span class="nav-text">第四步：添加系统调用基类。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第4-5步：添加第一个系统调用"><span class="nav-number">1.9.2.5.</span> <span class="nav-text">第4.5步：添加第一个系统调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第五步：任务管理"><span class="nav-number">1.9.2.6.</span> <span class="nav-text">第五步：任务管理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#网络服务器的搭建："><span class="nav-number">1.9.3.</span> <span class="nav-text">网络服务器的搭建：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#非阻塞的I-O"><span class="nav-number">1.10.</span> <span class="nav-text">非阻塞的I/O</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第八部分：协程栈的一些问题的研究。"><span class="nav-number">1.11.</span> <span class="nav-text">第八部分：协程栈的一些问题的研究。</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#我们可能在使用yield的时候会遇到一些问题："><span class="nav-number">1.11.1.</span> <span class="nav-text">我们可能在使用yield的时候会遇到一些问题：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#让我们来看看这个叫蹦床的奇淫巧技。"><span class="nav-number">1.11.2.</span> <span class="nav-text">让我们来看看这个叫蹦床的奇淫巧技。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#控制流："><span class="nav-number">1.11.3.</span> <span class="nav-text">控制流：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第九部分：最后的一些话。"><span class="nav-number">1.12.</span> <span class="nav-text">第九部分：最后的一些话。</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#更加深远的一些话题。"><span class="nav-number">1.12.1.</span> <span class="nav-text">更加深远的一些话题。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#让我们对yield一点小尊重："><span class="nav-number">1.12.2.</span> <span class="nav-text">让我们对yield一点小尊重：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在下列三种蛀牙的情况下我们可以想起来，使用yield。"><span class="nav-number">1.12.3.</span> <span class="nav-text">在下列三种蛀牙的情况下我们可以想起来，使用yield。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最后"><span class="nav-number">1.12.4.</span> <span class="nav-text">最后</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LumiaXu</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.1.2</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.2"></script>

  <script src="/js/motion.js?v=7.1.2"></script>



  
  


  <script src="/js/affix.js?v=7.1.2"></script>

  <script src="/js/schemes/pisces.js?v=7.1.2"></script>



  
  <script src="/js/scrollspy.js?v=7.1.2"></script>
<script src="/js/post-details.js?v=7.1.2"></script>



  


  <script src="/js/next-boot.js?v=7.1.2"></script>


  

  

  

  


  


  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
